---
title: '自作言語「DICE」のご紹介 - 並列処理が得意な言語のプロトタイプ'
date: '2025-08-04'
tags: ['Python', '言語開発', '個人開発']
---

## 背景と目的

`DICE`は、IoTやリアルタイム制御といった「並列性が本質的に重要な分野」に向けて設計したプログラミング言語です。

現状の言語で並列処理を行うには、非同期処理の理解や複雑なスレッド制御が必要で、習得コストも高くなりがちです。  
また、コード上で依存関係や処理順序が直感的に見えないことが多く、バグや意図しない挙動の原因になっています。

そこで DICE では、
- 並列処理を言語レベルでサポートし、
- 依存関係を明示的に記述でき、
- リアルタイム性を意識した実行時間の可視化も支援する

そんな言語を目指しています。

## 基本文法と構文の工夫

### 1. 基本文法

DICEのコンセプトのひとつは、処理の依存関係を視覚的に表現することです。  
そのために、次の文法を設計しています。

- `parallel { ... }` または `p{ ... }` で囲むだけで、その中のタスクが並列で実行される
- `->` 演算子を使うことで、左から右へ処理が流れていくことを自然に表現する
- `@timed` アノテーションをつけるだけで、関数やブロックの実行時間を計測できる  
→ 実行タイミングがシビアなリアルタイム処理などで、パフォーマンスの可視化に役立ちます

例えば、以下のコードをご覧ください。

```dice
// 「aの完了後bを実行する処理」と、「cを実行する処理」を並列で行い、
// その両方が終わったらdを実行する
// 上記の処理すべてにかかった時間を計測する
@timed
p {
    a() -> b()
    c()
} -> d()
```

このような複雑になりがちな依存関係を、非常にすっきりと記述できるのがDICEの大きな特徴です。

この仕様を実装するために、ブロックを「文」ではなく「式」として扱っています。  
つまり、`p {}` や `if {}` が、値を持つ「式」になります。

これにより、`p {} -> task()`のように `->` 演算子で繋ぐことができます。

### 2. 並列タスクの記述

`taskunit` と `parallelTasks()`、そして`.next()`メソッドの組み合わせは、複数のオブジェクト（例えば、複数のロボットアームやセンサー）が協調して段階的に動作するような、複雑なシナリオを驚くほどシンプルに記述できます。

```dice
// ロボットアームAとBで、それぞれ物を掴んで移動する動作を同期させる
group = parallelTasks(ArmA(), ArmB());

// step1：掴む動作（両アームが掴み終わるのを待つ）
group.next();

// step2：持ち上げる動作（両アームが持ち上げ終わるのを待つ）
group.next();

// step3：所定の位置に置く
group.next();
```

`.next()`を呼び出すたびに、全オブジェクトの次のステップが並列実行され、その完了が暗黙的に同期されます。  
これにより、手動でバリア同期を実装する必要がなく、安全かつ簡潔に記述できます。

## プロトタイプ実装

### 1. 現状について

現在は`Python`によるプロトタイプを開発中です。

- 構文解析・実行系：独自のパーサーを構築し、ASTベースで実行
- テスト環境：`pytest`ベースで多数の構文テストを用意

### 2. 悩んだ部分

構文仕様は試行錯誤しながら調整中で、`p`ブロック内の別ブロックの動作仕様には特に悩みました。  
例えば次のようなコードです。

```dice
func main() {
    p {
        if (true) {
            // 並列ブロック内なので、並列で処理すべき？
            // 並列ブロックの直下ではないので、順次で処理すべき？
            wait(2);
            wait(3);
        }

        wait(2);
    }
}
```

現在は**pブロック直下のみ並列処理**になっており、別ブロック内の処理は順次処理という仕様にしています。  
その理由は、同じコードで挙動が変わることを避けるためです。

```dice
if (true) {
    wait(2);
    wait(3);
}
```

このようなコードの挙動を、`p`ブロックの内外で変えてしまうと、バグを生みやすい設計になってしまいます。

そのため、冗長ですが`if`ブロック内で並列処理を行う場合は、次のように書く必要があります。

```dice
func main() {
    p {
        if (true) {
            p {
                wait(2);
                wait(3);
            }
        }

        wait(2);
    }
}
```

## 感想

MVPは完成しましたが、まだ実用段階には至っていません。  
今後は、型システムやリスト構造の導入、さらなる最適化などを検討していく予定です。

実は過去にも「Green」というプログラミング言語を作ったことがあり、今回が2作目の言語開発になります。  
2つの言語を自作してみて強く感じたのは、「**仕様を考えることの難しさ**」です。

「どうすれば使いやすい言語になるのか」という問いに、明確な答えは見つかりませんでした。  
しかし、「なぜこの仕様にしたのか」を**自分の言葉で説明できることが何より大切**だと感じています。  
これは言語開発に限らず、あらゆる開発に通じる姿勢だと思います。

最近では、vibe codingのようにAIにコードを書かせる機会も増えています。  
それでも、「どうすれば使いやすいか」を考えるのは、いまのところ人間にしかできない部分です。  
この思考だけは、これからも大切にしていきたいと思います。
