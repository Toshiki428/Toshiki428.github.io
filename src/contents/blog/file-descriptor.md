---
title: 'ファイルディスクリプタについて。プログラムの入力元・出力先は？'
date: '2025-12-26'
tags: ['低レイヤー', 'OS', 'Linux']
category: 'STUDY_LOG'
---

最近、ZeroMQ（ZMQ）を使う機会があり、「ZMQはFDのような低レイヤーの仕組みを制御するから高速だ」という情報を知りました。  
この「FD」というものを全く知らず、今回勉強したので成果をまとめてみます。

## 事前知識

### 1. カーネル

一言で言うと、**OSの中核のプログラム**で、ユーザプロセス（アプリ）を健全に動作させる役割を持つプログラムです。

詳しくは前回の記事でまとめているので、そちらもご覧ください。

[カーネルとは？カーネルの役割とCPUの特権レベル](/#/blog/kernel)

### 2. Everything is a file

UNIX系OSの設計思想で、ファイル、ディレクトリ、デバイス、ネットワークソケット、プロセスなど、**システム内のあらゆるリソースをファイルとして統一的に使えるようにする概念**です。

全てを抽象化して「ファイル」として使えるようにすることで、プログラマは4つの基本動作のみで、コンピュータの全てを操れます。
- `open`：窓口を開く
- `close`：窓口を閉じる
- `read`：データを取り出す
- `write`：データを流し込む

例えば、SSDのファイルに書き込むときも、ネットワークで送信するときも、`write`というシステムコールを使います。  
ここで大切なのは、SSDもネットワークもどちらも**ファイルとして扱う**ので、実行するときの対象とするファイルを切り替えるだけで実装できる点です。

この設計のおかげで、プログラム側を改造することなく入力元や出力先を自由に繋ぎかえることができます。

## FDとは

FD（File Descriptor）とは、ユーザプロセスがシステムコールをするときに、**対象のファイル（デバイスやネットワークソケットなど）を指定する数字**です。

例えば、`echo "Hello"`とターミナルで実行すると、裏側では`write`が動きます。  
`write`は「この文字をこの窓口に出力してください」という命令の形になっており、「窓口」を指定する数字がFDです。

### FDとカーネル

FDの管理は**カーネル**が担当し、プロセスがファイルやソケットを開くたびに新しくFDを作ります。  
もしFDをプロセス側で管理すると、プロセスの責任が増えプログラムが大変になったり、ハードウェアを触る部分でもあるのでセキュリティ上のリスクが増えます。

カーネルはFDを作るとき、「このファイルは3番」「このソケットは4番」のように番号を振り、番号のみをプロセス側に伝えます。

プロセス側は、その番号を使って、システムコールをします。  
例えば、`write(fd, data, size)`のように引数としてFDを指定します。

この`fd`が、SSDのファイルなら「保存」になり、ソケットなら「送信」、ディスプレイなら「表示」になります。

このように、*Everything is a file*という設計思想により非常に抽象化されているため、機械語レベルのプログラムでは「ファイル保存」と「送信」がFDを切り替えるだけで、他はほとんど同じになります。

### FDの予約番号（標準ストリーム）

どんなプロセスも、起動した瞬間に**標準ストリーム（Standard Streams）** と呼ばれる3つのFDをデフォルトで預かっています。  
この番号は最も基本的なもので、プロセスの必要に応じて、4つ、5つと増えていきます。

- `0`：標準入力（stdin）
- `1`：標準出力（stdout）
- `2`：標準エラー出力（stderr）

## FDの確認

では、実際にFDの確認をしてみます。  
FDのリンク先はファイルなので、lsコマンドで確認することができます。

```sh
ls -l /proc/self/fd
```

`/proc/self/fd`とは、自分自身のプロセスのFDという意味です。  
つまりこの場合、ターミナルにとってのFDの一覧を確認するというコマンドになります。  
> ちなみに、特定のプロセスのFDを調べたい場合、`/proc/<PID>/fd`を確認します。

結果は次のようになりました。

```txt
lrwx------ 1 name name 64 12月 21 20:46 0 -> /dev/pts/0
lrwx------ 1 name name 64 12月 21 20:46 1 -> /dev/pts/0
lrwx------ 1 name name 64 12月 21 20:46 2 -> /dev/pts/0
lr-x------ 1 name name 64 12月 21 20:46 3 -> /proc/9307/fd
```

`0`、`1`、`2`は同じ、`/dev/pts/0`にリンクしています。

### ptsとは

`pts`とは、**Pseudo Terminal Slave** （仮想端末）の略です。  
これは、**ターミナルとシェルを繋ぐ通信路**のようなものです。

少し詳しくまとめると、ターミナルとは「ユーザからの入力を受け取り、表示も担当するGUIアプリ」です。  
シェルとは「ターミナルから送られる文字を解釈して、カーネルにプログラム実行の命令を出すソフトウェア」です。

しかし、ターミナルからシェルに直接文字が送られるわけではありません。  
その理由は、*Everything is a file*の思想で、**シェルはファイルからしか情報を受け取らない**ようになっているからです。

なので、ターミナルはファイルに書き込む、シェルはファイルから読み込む、という共有のメモ帳のようなものを使う形をとっています。

このメモ帳こそ、`pts`です。

このような設計にしているからこそ、シェルがいろんなターミナルで使えるわけです。

また、あえて「ファイル」という形にしているため、「既存のファイル操作コマンドが使える」というメリットがあります。  
例えば、別ターミナルに文字を出すということもできます。

簡単なテストとして、2つのターミナルを開いてそれぞれがFDで繋がっているファイルを確認します。  
今回は`/dev/pts/0`と`/dev/pts/1`でした。

`/dev/pts/0`の方のターミナルに、`echo "Hello" > /dev/pts/1`と打ってみます。  
すると、`/dev/pts/1`の方のターミナルに`Hello`と表示されていることが確認できました。

*Everything is a file*のおかげで、プログラムを交換可能にできていることが実感できます。

### ネットワークソケットの確認

では続いて、ネットワークを使っているプロセスを追跡してみましょう。

まずは、Pythonを使って簡易サーバを立ち上げます。

```sh
python -m http.server 8080
```

次に、別のターミナルから、そのサーバのPIDを調べます。

```sh
pgrep -f "http.server"
```

今回は、PIDが15だったとして、そのPIDのFDを確認してみます。

```sh
ls -l /proc/15/fd
```

すると、このような結果が表示されました。

```txt
lrwx------ 1 name name 64 12月 21 21:03 0 -> /dev/pts/1
lrwx------ 1 name name 64 12月 21 21:03 1 -> /dev/pts/1
lrwx------ 1 name name 64 12月 21 21:03 2 -> /dev/pts/1
lrwx------ 1 name name 64 12月 21 21:03 3 -> 'socket:[217330]'
```

`3 -> 'socket:[217330]'`というものが追加されています。  
この`[]`内の数字は、 **inode（アイノード）番号** と呼ばれる、OSが管理するオブジェクトのIDです。

Linuxでは、`/proc/net/tcp`という、システム全体の通信記録を確認できる場所があり、そこで`217330`に対応する行を探すことができます。

```sh
cat /proc/net/tcp
```

すると、このような結果が表示されました。
必要な行のみ抽出しています。

```txt
  sl  local_address rem_address   st tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode                                                     
   ...
   3: 00000000:1F90 00000000:0000 0A 00000000:00000000 00:00000000 00000000  1000        0 217330 1 0000000000000000 100 0 0 10 0                    
   ...
```

ファイルの中身は16進数で書かれるため、少しわかりにくいですが、`local_address`を解読してみます。

`00 00 00 00` は、IPアドレスで `0.0.0.0`、`1F90` は、16進数から10進数へ次のように変換できます。

`1*16^3 + 15*16^2 + 9*16^1 + 0*16^0 = 4096 + 3840 + 144 + 0 = 8080`

この計算により、ポート番号が`8080`であることがわかります。

ちなみに、`local_address`は、リトルエンディアンで書かれるため、`127.0.0.1`の場合、`0100007F`のように表記されます。  
今回は`0.0.0.0`のため、気にしなくて済んだのですが、将来的に必要になる知識です。

今やった、FDからポート番号を調べる処理は、`lsof -i :<ポート番号>`というコマンドを実行した時に走る処理と同じです。  
`lsof`コマンドは、**プロセスが開いているファイルを表示するコマンド**で、FDとも非常に関係している部分なので、よければ調べてみてください。

## パイプやリダイレクトの仕組み

Linuxのコマンドに`|`（**パイプ**）や、`>`（**リダイレクト**）という書き方があります。

これらは、FDを使うことによる抽象化のおかげで成り立っています。

### パイプ

パイプとは、`|`直前の実行結果を、`|`直後のコマンドの標準入力とする書き方です。  
ここでは、次のコマンドを考えてみます。

```sh
cat log.txt | grep "Error"
```

このコマンドの場合、`cat`プロセスは、ただFD1番（標準出力）にデータを書き込み、あとはカーネルに任せます。  
同じように、`grep`プロセスも、FD0番（標準入力）からデータを読み込み、それ以前はカーネルに任せます。

つまり、このパイプは、各プロセスの**挙動を一切変えず**、カーネル側でFDの先を差し替えることで実現しています。  
では少し詳しく、カーネルがプログラム起動直前にする細工をみてみます。

1. 初めにデータの通り道（パイプ）をメモリ上に作ります
2. `cat`プロセスのFD1番を書き換え、1で用意したパイプに繋がるように設定します
3. `grep`プロセスのFD0番を書き換え、1で用意したパイプの出口に繋がるように設定します

ここで重要なのは、`cat`も`grep`も、自分がパイプに繋がっていることは知らないという点です。  
`cat`はいつも通り`write(1, ...)`を、`grep`はいつも通り`read(0, ...)`を実行しています。

このように、プログラムを書き換えずにカーネル側で接続先を切り替えるだけで、データの流れを自由に組み換えられるのは、Everything is a fileの恩恵です。

### リダイレクト

リダイレクトとは、`>`直前の実行結果を、`>`直後のファイルに出力する書き方です。  
実は`1>`という形を省略したのがこの書き方で、「FD1番（標準出力）の先をファイルにする」という意味です。

次のコマンドを考えてみます。

```sh
ls > test.txt
```

このコマンドの場合は、次のような動作をします。

1. **ファイルの準備**  
    初めに、書き込み先となる`test.txt`を新規作成、または上書きオープンします。  
    このとき、カーネルはFDを新しく作り（今回は3番）、このファイルに繋がるように割り当てます。
2. **FDのすり替え**  
    カーネルは、`ls`プロセスのFD1番の先をFD3番と同じものに書き換えます。  
    これにより、一時的に`1 -> test.txt`というリンクが完成します。
3. **プログラムの起動**  
    1、2が完了すると、`ls`を実行します。  
    `ls`プロセスは、**いつも通り1番に書き込みます**が、カーネル側で繋ぎ変えられているため、結果は画面に表示されず`test.txt`ファイルに書き込まれています。

この動きを理解すると、Linuxでよく使われる`2>&1`という書き方の意味も理解できます。  
これは「FD2番（標準エラー出力）の先を、FD1番（標準出力）と同じ場所にする」というFDの書き換え命令です。

では、ここで少し実験してみます。

まず、存在しないコマンド`LS`を実行し、標準出力(`stdout`)と標準エラー出力(`stderr`)の挙動を確認します。  
通常のリダイレクトなので、標準出力だけが `test.log` に書き込まれます。

```sh
# "Normal"は標準出力、"LS"は存在しないコマンドなので標準エラー出力に出る
[name@host shell]$ (echo "Normal"; LS) > test.log
bash: LS: コマンドが見つかりませんでした...

# test.log を確認すると、標準出力だけが書き込まれている
[name@host shell]$ cat test.log
Normal
```

次に、`2>&1`を使って、標準エラー出力(FD2)の出力先を標準出力(FD1)と同じ場所にします。  
これにより、`LS`コマンドのエラーメッセージも`test.log`に書き込まれます。

```sh
# 2>&1 を追加
[name@host shell]$ (echo "Normal"; LS) > test.log 2>&1

# エラーメッセージもファイルに書き込まれたため、ターミナルには何も表示されない
[name@host shell]$

# test.log を確認すると、標準出力と標準エラー出力の両方が書き込まれている
[name@host shell]$ cat test.log
Normal
bash: LS: コマンドが見つかりませんでした...
```

この場合`2>&1`は、`>` (`1>`)の**リダイレクトの後に書く必要があります**。  
先に書くと解釈の順番が変わり、意図した通りに動作しないので注意が必要です。

また、リダイレクトの先はファイルだけではありません。  
`/dev/pts/1`のように別ターミナルを指定することでそのターミナルに表示でき、  
`/dev/tcp/google.com/80`のように指定することでデータはインターネットに進みます。

## まとめ

前回のカーネルに引き続き、今回はFDについてまとめてみました。

Linuxのこの辺りの分野は、掘れば掘るほど情報が出てきて迷子になりがちです。

実はこの記事も「ZeroMQについてまとめよう」から始まり、「カーネルについて」「FDについて」と寄り道をしているところです。

近いうちに本来の目的であったZeroMQについてまとめるつもりなので、そちらもぜひご覧ください。

ちなみに、このブログを書いていて、「リアルタイムで使っているポート番号やFDを表示させる自作ツール」を開発してみたいなと思いました。  
簡単な仕様としては、そのプログラム上で子プログラムを動かすことができ、子プログラムのデバッグに使えるようなものを想定しています。

`strace`でできてしまい車輪の再発明になりそうですが、「理解を深めるために」もやりたいことリストとして置いておこうと思います。

