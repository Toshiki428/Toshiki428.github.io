---
title: 'SSH接続時のパケットを確認'
date: '2025-10-08'
tags: ['SSH', 'WireShark', 'パケット解析']
category: 'STUDY_LOG'
---

本記事では、SSH接続のパケットキャプチャによって接続時の処理を確認してみます。

## SSHとは

はじめに、SSHについて簡単にまとめます。

SSH（Secure Shell）は、ネットワーク越しに他のコンピュータへ安全に接続し、コマンド操作やファイル転送などを行うためのプロトコルです。  
元々は、暗号化されていないTelnetの代用として開発され、通信内容をすべて暗号化して保護します。

ウェルノウンポートは22番で、リモートログイン、ファイル転送（SCP/SFTP）、ポートフォワーディングなどに利用されます。

## 接続までの簡単な流れ

先ほど説明したように、SSH通信は暗号化されています。

暗号化するためには、暗号化と復号に使う共通鍵を交換しておく必要があります。  
ただし、暗号化されていても、通信相手が正しいサーバであることを確認できなければ「**中間者攻撃**」を受けるおそれがあります。

そこで、SSHは次の手順で安全な通信を確立します。

1. **接続要求**：クライアントがサーバに「接続したい」と伝え、通信路の確立とプロトコルバージョン交換を行う
2. **サーバ認証**：サーバはクライアントに「自分が正当なサーバであること」を証明する
3. **鍵交換**：サーバ認証と並行して、サーバとクライアント間で安全に共通鍵を生成し、以降の通信を暗号化する
4. **クライアント認証**：クライアントが「自分が正当なユーザであること」を証明する

### 1. 接続要求

サーバ側はデーモン（`sshd`）として常時待ち受けており、接続要求を受け取る体制が整っています。

クライアントは`ssh user@192.168.0.1`などのコマンドでサーバに接続要求を送ります

このとき、TCPの**3ウェイハンドシェイク**によってポート22番への通信路が確立されます。  
そして、クライアントとサーバがそれぞれ対応しているプロトコルバージョンを送り合ってSSH通信の準備が完了します。

> `ssh`コマンドでユーザ名を指定していますが、ユーザ名がサーバへ送信されるのはクライアント認証の段階です。  
> つまり、暗号化ができるようになってから、ユーザ名が送信される仕様です。

### 2. サーバ認証

説明のために、クライアントが`サーバA`にSSH接続しているとします。

通信路が確立すると、`サーバA`は自分が正当なサーバであることを証明するために、**ホスト鍵（サーバの公開鍵・秘密鍵ペア）** を使い、鍵交換の過程で得られたハッシュ値に秘密鍵で署名し、公開鍵と共にクライアントに送ります。

クライアントは「受け取った署名」を公開鍵で検証することで、そのサーバがホスト鍵の正当な所有者であることを確認します。

しかし、この手続きだけでは「受け取った公開鍵が本当に`サーバA`のものだ」という保証にはなりません。  
例えるなら、「封のされた手紙が無傷で届けば、**内容は改ざんされていない**と分かるが、その封筒が`サーバA`から来たのか、`サーバB`から来たのかまではわからない」ということです。

実際、ここがSSHで注意すべき点であり、最初の接続時には「本当に正しい相手か」を確認する必要があります。  
初回接続時に`Are you sure you want to continue connecting (yes/no/[fingerprint])?`と聞かれるのは、「初めて接続するサーバだけど、信頼して大丈夫？」というユーザーへの問いです。

`yes`を選択すると、クライアントはそのサーバの**フィンガープリント（公開鍵の短いハッシュ）** を`~/.ssh/known_hosts`に記録します。  

次回以降は、その記録と照合して「前回と同じサーバであること」を確認することで、なりすましを防ぎます。  
もし不一致なら**中間者攻撃（MITM攻撃）** の検出を目的として警告が出るようになっています。

この「初回で相手をよく調べた上で信用し、以降は以前と同じ相手かどうかだけをチェックする」方針を、**TOFU（Trust On First Use）** といいます。

### 3. 鍵交換

SSHでは、**Diffie–Hellman（DH）鍵交換方式**を使って、サーバとクライアントが安全に共通鍵を生成します。

この方式の特徴は、共通鍵そのものを送信せずに、**両者が乱数を用いて同じ値を計算で導き出せる**点です。  
そのため、通信経路上でデータを盗聴されても、共通鍵を第三者が知ることはできません。

また、鍵交換の過程でサーバの秘密鍵は署名にしか使っていないので、万が一、サーバの秘密鍵が漏れても過去の通信内容が解読されることはありません。  
これを**PFS（Perfect Forward Secrecy）** といいます。

こうして生成された共通鍵は、以降の通信（認証情報やコマンド実行結果など）を暗号化するために使われます。

### 4. クライアント認証

サーバの認証が完了し、暗号化通信が確立したら、最後にクライアントの認証を行います。

SSHでは主に2つの認証方法があります。

- **パスワード認証：**  
クライアントがユーザ名とパスワードをサーバに送信します。
これらの情報は、先ほど確立した暗号化通信によって保護されているため、安全に送信できます。
- **公開鍵認証：**  
事前にクライアントの公開鍵をサーバに登録しておき、接続時にクライアントは自分の秘密鍵で署名を行います。  
サーバが登録済みの公開鍵でその署名を検証し、正当なユーザであることを確認します。  
パスワードを送信しないため、より安全性が高い方法です。

## パケットキャプチャで見るSSH接続

ここでは、SSH接続のパケットキャプチャ結果と、本文で解説した手順の対応を見ていきます。

### TCP接続の確立

![TCP接続の確立キャプチャ](/images/blog/ssh-1.png)

- 1 〜 3：**3ウェイハンドシェイク**。ポート 22 への通信路を確立

### プロトコルバージョン交換

![プロトコルバージョン交換キャプチャ](/images/blog/ssh-2.png)

- 4, 6：互いの SSH バージョンを確認し、鍵交換の準備へ

### 鍵交換 と サーバ認証

![鍵交換とサーバ認証キャプチャ](/images/blog/ssh-3.png)

- 8 〜 10：使用する暗号アルゴリズムなどの**ネゴシエーション**を開始
- 12：**クライアント**が、**鍵交換に必要な公開パラメータ**を**サーバへ送信**
- 13：**鍵交換が完了**。ホスト鍵による**サーバ認証**もこの過程で実行され、通信が暗号化される

13のパケットの中身はこのようになっています。

![サーバ認証キャプチャ詳細](/images/blog/ssh-4.png)
- `KEX host signature (type: ssh-ed25519)`：ホスト鍵による署名。これを検証してサーバが正当か判定する
- `Host signature data` の 64 バイトが実際の Ed25519 署名値（クライアントはこれを known_hosts の公開鍵で検証）

### クライアント認証

![クライアント認証キャプチャ](images/blog/ssh-5.png)

- 46〜：**クライアント認証**。以降の通信はすべて暗号化されているため、パケットの中身は見えなくなる

## まとめ

本記事では、SSH接続のシーケンスを、実際のパケットキャプチャを確認しつつ解説しました。

普段何気なく使っている`ssh`コマンドですが、その裏側では、

1. **接続要求**（TCP接続とプロトコルバージョンの交換）
2.  **鍵交換**による共通鍵の生成と、ホスト鍵による**サーバ認証**
3.  パスワードや公開鍵による**クライアント認証**

といった多段階のプロセスを経て、安全な通信路が確立されています。

特に、サーバのなりすましを防ぐ**TOFU**の仕組みや、万が一秘密鍵が漏れても過去の通信を守る**PFS**といった重要なセキュリティ概念が、この一連の流れの中で実現されていることが確認できました。

コマンドの裏側で何が起きているかを理解することで、より深く仕様を理解することができます。
